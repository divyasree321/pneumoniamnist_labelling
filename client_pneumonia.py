# -*- coding: utf-8 -*-
"""pneuminiamnist.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1w2tzBJZSqD_Agp7wn6WWn7HijEAWLrXB
"""

!pip install medmnist --quiet
!pip install torch torchvision --quiet

import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import DataLoader
from torchvision import transforms, models
from medmnist import INFO, PneumoniaMNIST
from sklearn.metrics import accuracy_score, roc_auc_score
import numpy as np
import matplotlib.pyplot as plt

# Dataset config
data_flag = 'pneumoniamnist'
info = INFO[data_flag]
DataClass = getattr(__import__('medmnist'), info['python_class'])

# Transforms
transform = transforms.Compose([
    transforms.ToTensor(),
    transforms.Normalize(mean=[.5], std=[.5])
])

# Download datasets
train_dataset = DataClass(split='train', transform=transform, download=True)
val_dataset   = DataClass(split='val', transform=transform, download=True)
test_dataset  = DataClass(split='test', transform=transform, download=True)

# Dataloaders
train_loader = DataLoader(dataset=train_dataset, batch_size=64, shuffle=True)
val_loader   = DataLoader(dataset=val_dataset, batch_size=64, shuffle=False)
test_loader  = DataLoader(dataset=test_dataset, batch_size=64, shuffle=False)

# Number of classes
n_classes = len(info['label'])

images, labels = next(iter(train_loader))
fig, axes = plt.subplots(2, 3, figsize=(10, 7))

for i, ax in enumerate(axes.flat):
    img = images[i].squeeze().numpy()
    ax.imshow(img, cmap='gray')
    ax.set_title(f"Label: {int(labels[i].item())}")
    ax.axis('off')

plt.tight_layout()
plt.show()

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

model = models.resnet18(pretrained=True)

# Modify first conv layer for 1-channel input
model.conv1 = nn.Conv2d(1, 64, kernel_size=7, stride=2, padding=3, bias=False)

# Replace final FC layer for binary classification
model.fc = nn.Sequential(
    nn.Linear(model.fc.in_features, 1),
    nn.Sigmoid()  # since binary classification
)

model = model.to(device)

criterion = nn.BCELoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

num_epochs = 5

for epoch in range(num_epochs):
    model.train()
    running_loss = 0.0

    for images, labels in train_loader:
        # Remove the extra unsqueeze(1) here
        images, labels = images.to(device), labels.to(device).float() # Labels should be float for BCELoss

        optimizer.zero_grad()
        outputs = model(images)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()

        running_loss += loss.item() * images.size(0)

    epoch_loss = running_loss / len(train_loader.dataset)

    print(f'Epoch [{epoch+1}/{num_epochs}], Loss: {epoch_loss:.4f}')

model.eval()
y_true, y_pred = [], []

with torch.no_grad():
    for images, labels in test_loader:
        images = images.to(device)
        outputs = model(images).cpu().numpy()
        y_pred.append(outputs)
        y_true.append(labels.numpy())

y_true = np.concatenate(y_true)
y_pred = np.concatenate(y_pred)

# Binarize predictions at 0.5 threshold
y_pred_class = (y_pred >= 0.5).astype(int)

# Accuracy
acc = accuracy_score(y_true, y_pred_class)
print(f"Test Accuracy: {acc:.4f}")

# AUC Score
auc = roc_auc_score(y_true, y_pred)
print(f"Test AUC: {auc:.4f}")

plt.figure(dpi=120)

# Set model to evaluation mode
model.eval()

# Class names for PneumoniaMNIST (0: Normal, 1: Pneumonia)
classes = ['Normal', 'Pneumonia']

# Get one batch from test loader
dataiter = iter(test_loader)
images, labels = next(dataiter)

# Move to device if needed
images = images.to(device)

# Inference
with torch.no_grad():
    outputs = model(images)
    _, preds = torch.max(outputs, 1)

# Move everything back to CPU for display
images = images.cpu()
preds = preds.cpu()
labels = labels.cpu()

# Display images with predictions and true labels
fig = plt.figure(figsize=(12, 8))
for i in range(6):
    ax = fig.add_subplot(2, 3, i+1)
    img = images[i].permute(1, 2, 0).numpy()
    ax.imshow(img, cmap='gray')
    ax.set_title(f'Pred: {classes[preds[i]]} | True: {classes[labels[i]]}')
    ax.axis('off')

plt.tight_layout()
plt.show()

import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import DataLoader
from torchvision import transforms
import medmnist
from medmnist import INFO, Evaluator
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix
import seaborn as sns
from PIL import Image

# Set device
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

# 1. Load PneumoniaMNIST dataset
data_flag = 'pneumoniamnist'
info = INFO[data_flag]
DataClass = getattr(medmnist, info['python_class'])

# Data transformation
data_transform = transforms.Compose([
    transforms.ToTensor(),
    transforms.Normalize(mean=[.5], std=[.5])
])

# Load datasets
train_dataset = DataClass(split='train', transform=data_transform, download=True)
val_dataset = DataClass(split='val', transform=data_transform, download=True)
test_dataset = DataClass(split='test', transform=data_transform, download=True)

# Create data loaders
batch_size = 128
train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True)
val_loader = DataLoader(val_dataset, batch_size=batch_size, shuffle=False)
test_loader = DataLoader(test_dataset, batch_size=batch_size, shuffle=False)

# 2. Define model
class PneumoniaCNN(nn.Module):
    def __init__(self):
        super(PneumoniaCNN, self).__init__()
        self.features = nn.Sequential(
            nn.Conv2d(1, 16, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(kernel_size=2, stride=2),
            nn.Conv2d(16, 32, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(kernel_size=2, stride=2)
        )
        self.classifier = nn.Sequential(
            nn.Linear(32 * 7 * 7, 128),
            nn.ReLU(),
            nn.Linear(128, 2)  # 2 classes: normal and pneumonia
        )

    def forward(self, x):
        x = self.features(x)
        x = torch.flatten(x, 1)
        x = self.classifier(x)
        return x

model = PneumoniaCNN().to(device)

# 3. Training setup
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

import torch
from PIL import Image
import torchvision.transforms as transforms

def predict_image(image_path, model):
    # Load and preprocess the image
    # Convert to grayscale ('L') instead of RGB ('RGB')
    image = Image.open(image_path).convert('L')

    # Use the same transformation as used for the training data
    # This ensures consistent preprocessing (resize to 28x28 and 1-channel normalization)
    transform = transforms.Compose([
        transforms.Resize((28, 28)), # MedMNIST images are 28x28
        transforms.ToTensor(),
        transforms.Normalize(mean=[.5], std=[.5]) # Normalization for 1 channel
    ])

    image = transform(image).unsqueeze(0)  # Add batch dimension
    # Move the image tensor to the device the model is on
    image = image.to(next(model.parameters()).device)

    # Make prediction
    model.eval()
    with torch.no_grad():
        outputs = model(image)
        # The model returns raw logits for 2 classes (Normal, Pneumonia)
        # Apply softmax to get probabilities, then find the class with the highest probability
        probs = torch.softmax(outputs, dim=1)
        _, predicted = torch.max(probs, 1)

    # The model predicts class index (0 or 1). Map this to class names.
    classes = ['Normal', 'Pneumonia']
    predicted_class_name = classes[predicted.item()]

    return predicted_class_name

# Assuming sample_img_path and sample_label are available from a previous cell
# Ensure a sample image is saved to a temporary path if not already done
# For demonstration, let's quickly get one from the test dataset
# You might already have sample_img_path defined earlier, use that if available.
# from medmnist import PneumoniaMNIST
# from torchvision import transforms
# # Assuming test_dataset and device are already defined
# data_transform = transforms.Compose([
#     transforms.ToTensor(),
#     transforms.Normalize(mean=[.5], std=[.5])
# ])
# test_dataset = PneumoniaMNIST(split='test', transform=data_transform, download=True)
# sample_idx = 10
# sample_img_tensor, sample_label_tensor = test_dataset[sample_idx]
# sample_img_pil = transforms.ToPILImage()(sample_img_tensor)
# sample_img_path = "temp_sample_image_predict.png"
# sample_img_pil.save(sample_img_path)


# Make prediction
prediction = predict_image(sample_img_path, model)
# Need sample_label to print the actual label.
# Assuming sample_label (numpy array) is available from previous cells.
# If not, you would need to get it from the dataset like shown above.
print(f"Actual label: {'Pneumonia' if sample_label.item() == 1 else 'Normal'}")
print(f"Model prediction: {prediction}")

# # Optional: Clean up the temporary file
# import os
# if os.path.exists(sample_img_path):
#     os.remove(sample_img_path)

import ipywidgets as widgets
from IPython.display import display, clear_output
from PIL import Image
import io
import torch
import torchvision.transforms as transforms

# Assume model and device are already defined from previous cells
# Assume the predict_image function (the corrected version) is also defined

def on_upload_change(change):
    # This function is called when a file is uploaded
    uploaded_file = list(uploader.value.values())[0]
    image_bytes = uploaded_file['content']

    try:
        img = Image.open(io.BytesIO(image_bytes)).convert('L') # Load as grayscale
        # You can display the uploaded image if you like:
        # display(img) # Optional: display the image

        # Save the image temporarily to pass the path to your function
        temp_path = "uploaded_image_for_prediction.png"
        img.save(temp_path)

        # Make prediction using your existing function
        prediction = predict_image(temp_path, model)

        # Display the prediction result
        with output_area:
            clear_output(wait=True)
            print(f"Model prediction: {prediction}")

        # Clean up the temporary file
        import os
        if os.path.exists(temp_path):
             os.remove(temp_path)

    except Exception as e:
        with output_area:
            clear_output(wait=True)
            print(f"Error processing image: {e}")


# Create a file upload widget
uploader = widgets.FileUpload(
    accept='image/*',  # Accept image files
    multiple=False      # Allow only one file upload
)

# Create an output area to display results
output_area = widgets.Output()

# Link the upload widget to the event handler
uploader.observe(on_upload_change, names='value')

# Display the widgets
print("Upload an image to get a prediction:")
display(uploader, output_area)

# 5. Train the model
history = train_model(model, train_loader, val_loader, criterion, optimizer, num_epochs=15)

# 6. Plot training history
plt.figure(figsize=(15, 5))

# Loss plot
plt.subplot(1, 2, 1)
plt.plot(history['train_loss'], label='Train Loss')
plt.plot(history['val_loss'], label='Validation Loss')
plt.title('Training and Validation Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend()

# Accuracy plot
plt.subplot(1, 2, 2)
plt.plot(history['train_acc'], label='Train Accuracy')
plt.plot(history['val_acc'], label='Validation Accuracy')
plt.title('Training and Validation Accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.legend()

plt.tight_layout()
plt.show()

# 7. Confusion Matrix
def plot_confusion_matrix(model, data_loader):
    model.eval()
    all_preds = []
    all_targets = []

    with torch.no_grad():
        for inputs, targets in data_loader:
            inputs, targets = inputs.to(device), targets.squeeze().long().to(device)
            outputs = model(inputs)
            _, preds = torch.max(outputs, 1)
            all_preds.extend(preds.cpu().numpy())
            all_targets.extend(targets.cpu().numpy())

    cm = confusion_matrix(all_targets, all_preds)
    plt.figure(figsize=(6, 6))
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues',
               xticklabels=['Normal', 'Pneumonia'],
               yticklabels=['Normal', 'Pneumonia'])
    plt.title('Confusion Matrix')
    plt.xlabel('Predicted')
    plt.ylabel('Actual')
    plt.show()

plot_confusion_matrix(model, test_loader)

# Set model to evaluation mode
model.eval()

with torch.no_grad():
    # Get one batch from test loader
    dataiter = iter(test_loader)
    images, labels = next(dataiter)

    # Move to device if needed
    images = images.to(device)

    # Inference
    outputs = model(images)

    # For a model with a final Linear layer followed by CrossEntropyLoss:
    # Get the class index with the highest score
    _, preds = torch.max(outputs, 1)

    # If your model uses Sigmoid and BCELoss (like the first ResNet example):
    # outputs = model(images).squeeze() # Remove the extra dimension
    # preds = (outputs > 0.5).float().cpu().numpy() # Apply threshold for binary prediction

    # Move everything back to CPU for display
    images = images.cpu()
    preds = preds.cpu()
    labels = labels.cpu()

    # Class names for PneumoniaMNIST (0: Normal, 1: Pneumonia)
    classes = ['Normal', 'Pneumonia']

    # Display images with predictions and true labels
    fig = plt.figure(figsize=(12, 8))
    for i in range(6): # Display first 6 images from the batch
        ax = fig.add_subplot(2, 3, i+1)
        # Permute dimensions for matplotlib (channels last)
        img = images[i].permute(1, 2, 0).numpy()

        # Normalize image if needed for better visualization (optional, depends on your data transform)
        # img = (img - img.min()) / (img.max() - img.min())

        ax.imshow(img, cmap='gray') # Use cmap='gray' for single-channel images
        ax.set_title(f'Pred: {classes[preds[i]]} | True: {classes[labels[i]]}')
        ax.axis('off')

    plt.tight_layout()
    plt.show()

# 9. Enhanced image prediction with visualization
def predict_and_visualize(model, data_loader, index=0):
    model.eval()
    image, label = test_dataset[index]
    image = image.to(device).unsqueeze(0)

    with torch.no_grad():
        output = model(image)
        _, pred = torch.max(output, 1)
        prob = F.softmax(output, dim=1)[0] * 100

    # Create enhanced visualization
    img = image.squeeze().cpu().numpy()

    # Apply smoothing and contrast enhancement for display
    img = (img - img.min()) / (img.max() - img.min())

    plt.figure(figsize=(8, 4))
    plt.subplot(1, 2, 1)
    plt.imshow(img, cmap='gray')
    plt.title(f'Original Image\nActual: {"Pneumonia" if label.item() == 1 else "Normal"}')
    plt.axis('off')

    plt.subplot(1, 2, 2)
    # Apply Gaussian blur for smoother display
    from scipy.ndimage import gaussian_filter
    smoothed_img = gaussian_filter(img, sigma=0.8)
    plt.imshow(smoothed_img, cmap='gray')
    plt.title(f'Predicted: {"Pneumonia" if pred.item() == 1 else "Normal"}\n'
              f'Confidence: {prob[pred.item()]:.2f}%')
    plt.axis('off')

    plt.tight_layout()
    plt.show()

    return pred.item()

# Example prediction with visualization
sample_idx = 42  # Try different indices
prediction = predict_and_visualize(model, test_loader, sample_idx)
print(f"Model prediction: {'Pneumonia' if prediction == 1 else 'Normal'}")